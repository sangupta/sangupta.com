---
title: 101 Reasons - My Take - Part 3
date: 13 Mar 2007
tags: 
- java
- just-like-that
alias:
- /tech/101-reasons-my-take-part-3.html
- /2007/03/101-reasons-my-take-part-3.html
---

After a nice weekend, I am back to work today. It's a lovely day out here, with drizzle 
going on. The weather is too pleasant that I can't escape being romantic. But, work needs 
to be done. With nothing much in the office today, I continue with my take on the Java and 
.NET debate.

<!-- break here -->

<p><span style="color: #ff8000">REASON 21:</span> <a href="http://www.manageability.org/manageabilityWiki/NoEvilTypeCoercion">NoEvilTypeCoercion</a> - Some C++ constructs are meant to be entombed forever, .NET resurrects them with disastrous consequences.</p> 
<p><span style="color: #ff8000">MY TAKE:</span> With VC++ supporting the .NET platform, it could have been a much more disadvantage not to support the specific constructs. And to what disastrous constructs, the reference is, lies with the original author.</p> 
<p></p> 
<p>&nbsp;</p> 
<p><a href="http://www.manageability.org/manageabilityWiki/MoreLanguages"><span style="color: #ff8000">REASON 22: </span></a><a href="http://www.manageability.org/manageabilityWiki/MoreMatureAndRobustORMapping">More Mature And Robust O/R Mapping</a> - You can't beat the wealth of O/R mapping solutions found in Java.</p> 
<p><span style="color: #ff8000">MY TAKE:</span> O/R mapping solutions have come out late in the .NET world, but they have quickly chased upon. With NHibernate, Genome, AdFactum, and alike the .NET world is now flooded with many options.</p> 
<p></p> 
<p>&nbsp;</p> 
<p><a href="http://www.manageability.org/manageabilityWiki/MoreLanguages"><span style="color: #ff8000">REASON 23: </span></a><a href="http://www.manageability.org/manageabilityWiki/SuperiorCodingTools">Superior Coding Tools</a> - Like having your own personal Java fairy dancing through your code, anticipating your every thought and keystroke.</p> 
<p><span style="color: #ff8000">MY TAKE:</span> If it refers to the auto-completion features in IDE, then I must say the intellisense support came first and is much richer in .NET IDE platforms like VS and SharpDevelop. And if computers could capture every thought of developer, then what would be our need to the computing world.</p> 
<p></p> 
<p>&nbsp;</p> 
<p><a href="http://www.manageability.org/manageabilityWiki/MoreLanguages"><span style="color: #ff8000">REASON 24: </span></a><a href="http://www.manageability.org/manageabilityWiki/SaneCodingConventions">Sane Coding Conventions</a> - I don't know what's worse Hungarian notation or .NET coding conventions.</p> 
<p><span style="color: #ff8000">MY TAKE:</span> The coding conventions are almost similar in Java and .NET. Syntactically the difference lies, and that is obvious, for there are many languages out there. That apart, the language conventions are parallel in terms of power, flexibility, and maturity. Disagreed, specify an example!</p> 
<p></p> 
<p>&nbsp;</p> 
<p><a href="http://www.manageability.org/manageabilityWiki/MoreLanguages"><span style="color: #ff8000">REASON 25: </span></a><a href="http://www.manageability.org/manageabilityWiki/HigherPayingJobs">Higher Paying Jobs</a> - Somehow you've got to afford those skyrocketing housing prices don't you?</p> 
<p><span style="color: #ff8000">MY TAKE:</span> Come on, job salaries would be the last thing that can be compared when two different technical platforms are compared. It should be on the basis of robustness, ease of use, architecture-power, enterprise security and features. Salary circle too deceptive to be compared. For records, my sister in .NET gets equally paid (compared to me) with similar work experience in .NET.</p> 
<p></p> 
<p>&nbsp;</p> 
<p><a href="http://www.manageability.org/manageabilityWiki/MoreLanguages"><span style="color: #ff8000">REASON 26: </span></a><a href="http://www.manageability.org/manageabilityWiki/FavoredForImplementingP2P">Favored for Implementing P2P</a> - Gnutella and JXTA, anything else legally more pervasive?</p> 
<p><span style="color: #ff8000">MY TAKE:</span> I agree that Java is favored to implement P2P networks. But is the real reason the same as being quoted. I don't think so. Java being platform independent, provided for WORA (write once run anywhere) concept. With computers on a P2P network running on different Operating Systems, and with different underlying architecture, I would have been tough for them to port code from one platform to another. Hence, the obvious choice would have been Java.</p> 
<p>I think the real reason for Java being considered a better platform is the volume of target audience it attracts. With its platform independent runtimes, it leverages a real power against the .NET platform. </p> 
<p></p> 
<p>&nbsp;</p> 
<p><a href="http://www.manageability.org/manageabilityWiki/MoreLanguages"><span style="color: #ff8000">REASON 27: </span></a><a href="http://www.manageability.org/manageabilityWiki/PureJavaRDMS">PureJavaRDMS</a> - Can't beat the ease of installation when the RDMS is Java based and packaged with the application in a .zip file.</p> 
<p><span style="color: #ff8000">MY TAKE:</span> Till </p> 
<p></p> 
<p>&nbsp;</p> 
<p><a href="http://www.manageability.org/manageabilityWiki/MoreLanguages"><span style="color: #ff8000">REASON 28: </span></a><a href="http://www.manageability.org/manageabilityWiki/MoreExceptionHandlingOptions">More Exception Handling Options</a> - .NET has no analog to the throws clause in method signatures. </p> 
<p><span style="color: #ff8000">MY TAKE:</span> The throws clause is a real advantage to the Java developer. It is a robust exception handling construct which can definitely save hours of coding time to a developer trying to find out bugs in exception handling code. Microsoft are you listening???</p> 
<p></p> 
<p>&nbsp;</p> 
<p><a href="http://www.manageability.org/manageabilityWiki/MoreLanguages"><span style="color: #ff8000">REASON 29: </span></a><a href="http://www.manageability.org/manageabilityWiki/BetterStructuredDiagrammingFrameworks">Better Structured Diagramming Frameworks</a> - When going beyond forms and windows, Java can't be beat.</p> 
<p><span style="color: #ff8000">MY TAKE:</span> Structured programming frameworks. Ah!! one for the most hopeless arguments. A framework is a methodology/way of programming which increases robustness and reduces coding time. The frameworks available in .NET are as powerful as ones for Java, and for those migrating from Java, there are .NET ports for every major framework. NStruts, NHibernate, Spring.NET, etc.. the differentiating world seems to be narrowing upon.</p> 
<p></p> 
<p>&nbsp;</p> 
<p><a href="http://www.manageability.org/manageabilityWiki/MoreLanguages"><span style="color: #ff8000">REASON 30: </span></a><a href="http://www.manageability.org/manageabilityWiki/ReusableOpenSourceIDEFrameworks">Reusable Open Source IDE Frameworks</a> - Why re-invent the wheel? Start building your killer GUI application on top of killer IDE frameworks</p> 
<p><span style="color: #ff8000">MY TAKE:</span>&nbsp;Eclipse has really&nbsp;eclipsed the world of RCPs (Rich Client Platform's). It has thrown almost all IDE platform to waste-baskets. The power it unleashes is extra-ordinary. This is really one grey-area where the .NET platform is lagging behind. SharpDevelopIDE has tried to start racing in this domain, but the pace at which it is progressing, it might take a few years before it can catch up. But still the GUI looks that .NET platform inherits cannot be beaten by anyone except the stunning speciality of MacOS X.</p> 
<p></p> 
<p>&nbsp;</p> 
<p>The only reasons that I am convinced with, on this debate are the platform independent architecture of Java and the vast-resources of open-source projects available in Java. For every other reason, it seems like a child is being convinced for sleeping down at 9 in the night, as otherwise the monsters may come out. Well after 9, the monsters do come out. :-)</p>