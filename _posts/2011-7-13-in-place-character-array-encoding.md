---
layout: post
title: In-Place Character Array Encoding
permalink: /tech/in-place-character-array-encoding.html
redirect_from: "/2011/07/in-place-character-array-encoding.html"
date: Wed Jul 13 08:19:00 IST 2011
sharingURL: http://blog.sangupta.com/2011/07/in-place-character-array-encoding.html
tags: interview-questions java
---

<tt>Problem: </tt>Given a character stream as an array, encode the characters in place replacing given set of characters by their 3-character equivalent. The array is terminated by a 
<tt>0x00</tt> character. If the array cannot be fully encoded, the array should not be modified.
<br>
<br>
<tt>Solution: </tt>This is a classic interview problem. There are two aspects to this problem,
<br>
<ul>
    <li>Calculating whether the array would be able to contain the entirely encoded string. This can be easily achieved by calculating the length of the string, the number of encod<i>able</i> characters and the size of the array. If the free space in the array is equal to the additional capacity that would be needed by the encod<i>able</i> characters </li>
    <li>Encode the string from tail than from head. This is a must so that one does not override the characters ahead, when an encod<i>able</i> character is written encoded in the string.<br><br>A simple JAVA implementation is shown below.<br><pre class="brush:java">/**<br> * Copyright (C) 2010-2011, Sandeep Gupta<br> * http://www.sangupta.com<br> * <br> * The file is licensed under the the Apache License, Version 2.0<br> * (the "License"); you may not use this file except in compliance with<br> * the License.  You may obtain a copy of the License at<br> * <br> * http://www.apache.org/licenses/LICENSE-2.0<br> * <br> * Unless required by applicable law or agreed to in writing, software<br> * distributed under the License is distributed on an "AS IS" BASIS,<br> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br> * <br> * See the License for the specific language governing permissions and<br> * limitations under the License.<br> * <br> */<br><br>package com.sangupta.keepwalking;<br><br>import java.util.Arrays;<br><br>/**<br> * Class to encode a given character stream (defined as char[] array). The character array is the only<br> * memory space one has. In case encoding is not possible, the array should be left untouched. The array<br> * will be terminated by a <code>null</code> to indicate string termination.<br> * <br> * Each encodable character is 3 characters in length. Thus, additional space required would be 2 characters<br> * per each encodable character.<br> * <br> * @author sangupta<br> * @since 12 July 2011<br> */<br>public class CharacterStreamEncoder {<br><br>	/**<br>	 * @param args<br>	 */<br>	public static void main(String[] args) {<br>		char[] stream = new char[12];<br>		Arrays.fill(stream, '\0');<br>		stream[0] = 's';<br>		stream[1] = 'a';<br>		stream[2] = 'n';<br>		stream[3] = 'd';<br>		stream[4] = ' ';<br>		stream[5] = ' ';<br>		stream[6] = 'p';<br>		<br>		boolean result = encode(stream);<br>		if(result) {<br>			System.out.println(stream);<br>		} else {<br>			System.out.println("String was not modified.");<br>		}<br>	}<br>	<br>	public static boolean encode(char[] stream) {<br>		final int streamLength = stream.length;<br>		System.out.println("Total length: " + streamLength);<br>		<br>		// first we need to check if we can encode the string or not<br>		// in the given only space<br>		// so we read each character and count the total number of encodable<br>		// characters and also the length of the string.<br>		int encodable = 0;<br>		int length = 0;<br>		for(int index = 0; index &lt; stream.length; index++) {<br>			char temp = stream[index];<br>			if(temp == '\0') {<br>				break;<br>			} else {<br>				length++;<br>				if(isEncodable(temp)) {<br>					encodable++;<br>				}<br>			}<br>		}<br>		<br>		System.out.println("Length of string: " + length);<br>		System.out.println("Encodable: " + encodable);<br>		<br>		if(encodable == 0) {<br>			return true;<br>		}<br>			<br>		// now check for the balance length<br>		int balance = streamLength - length;<br>		if(encodable *2 &gt;= balance) {<br>			// not sufficient space in stream to encode<br>			return false;<br>		}<br>		<br>		// now we start from the end of the stream to encode<br>		// so that we do not override the characters before<br>		// as we already know the number of encodable characters<br>		// we know where the last character would be written<br>		int destination = length + encodable * 2 - 1;<br>		int source = length;<br>		<br>		for(int index = source; index &gt; 0; index--) {<br>			char character = stream[index - 1];<br>			char[] encoded = encode(character);<br>			if(encoded.length == 1) {<br>				stream[destination--] = encoded[0];<br>			} else {<br>				// we need to set the 3 character bytes properly<br>				stream[destination--] = encoded[2];<br>				stream[destination--] = encoded[1];<br>				stream[destination--] = encoded[0];<br>			}<br>		}<br>		<br>		return true;<br>	}<br><br>	private static boolean isEncodable(char character) {<br>		switch(character) {<br>			case ' ':<br>				return true;<br>				<br>		}<br>		<br>		return false;<br>	}<br>	<br>	private static char[] encode(char character) {<br>		switch(character) {<br>			case ' ':<br>				return new char[] { '%', '2', '0' };<br>		}<br>		<br>		return new char[] { character };<br>	}<br><br>}<br></pre></li>
</ul>
